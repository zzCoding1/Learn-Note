## 软件设计

### 1. 用例图

#### 1.1 基本概念

1. 组成

   - 参与制：人形图表示
   - 用例：椭圆表示
   - 关系

2. 站在使用者的角度，将整个软件系统描述出来，固定客户的需求

3. 关系

   - 泛化关系：表示同一个业务不同的技术实现

     ![image-20220714212213110](assets/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/image-20220714212213110.png)

   - 扩展关系：完成某一功能，偶尔会执行另一个功能

     ![image-20220714212454514](assets/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/image-20220714212454514.png)

   - 包含关系：一个用例可以包含其他的用例

     ![image-20220714212306918](assets/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/image-20220714212306918.png)

#### 1.2 案例

1. 需求
   - 人事管理系统。
     - 用户：人事管理干部
     - 功能：
       - 人事档案库
       - 人事信息管理
       - 生成报表

### 2. 类图

#### 2.1 基本概念

1. 三行的方块表示，自上而下分别是类名、属性、方法
2. 权限
   - +：表示公有
   - -：表示私有
   - #：表示保护

#### 2.2 类和类之间的关系

1. 泛化（继承）：实线三角

2. 接口（实现）：纯虚函数、抽象类模拟、虚线三角

3. 依赖：虚线箭头表示，A使用B，即A依赖B

   ![image-20220714214345774](assets/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/image-20220714214345774.png)

   - 代码实现：B作为A的参数、或者返回值

4. 关联：实现箭头表示

   ![image-20220714215053073](assets/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/image-20220714215053073.png)

   - 代码实现：B最为A的成员，作为A的返回值，或者被A使用。

   - 数量问题

     ![image-20220714215743202](assets/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/image-20220714215743202.png)

5. 聚合（是一种关联）：表示整体和部分，例如：汽车可以选择**各个型号**的发动机，空心菱形表示

   ![image-20220714215158752](assets/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/image-20220714215158752.png)

   

6. 组合（是一种关联）：关系更加强劲，表示**生命的**整体和部分**整体对象负责部分对象的生命周期**，例如人体和五脏六腑实心菱形表示

   ![image-20220714215223928](assets/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/image-20220714215223928.png)


#### 2.2 案例

略

### 3. 对象图

#### 3.1 基本概念

1. 是类图的一个实例,用于显示系统执行时的一个可能的快照,即在某一个时间上系统可能出现的样子,对象图用带下划线的对象名称来表示对象.

   ![image-20220714220934690](assets/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/image-20220714220934690.png)

### 3. 时序图

#### 3.1 基本概念

1. 用来描述对象间消息的传递

   ![image-20220714221244523](assets/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/image-20220714221244523.png)

   ![image-20220714221444338](assets/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/image-20220714221444338.png)

2. 组成

   - 对象:矩形表示,对象名称下有下划线,对象位于时序图的顶部说明交互开始时,对象已经存在,如果对象不在顶部,表示过程中被创建
   - 生命线:垂直的虚线表示,表示对象的生命周期
     - 虚线上矩形表示同步
   - 消息:表示对象的消息传递,一般是单向,时序图很少使用返回消息

#### 3.2 案例

1. 练习

   - 函数1 调用 函数2；

   - 函数2 调用 函数3；

   - 函数3返回后，函数2打印日志；

   - 最后函数2运行完毕后，返回到函数1；

2. 答案

   - 同步

     ![image-20220714222432438](assets/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/image-20220714222432438.png)

   - 异步

     ![image-20220714222531080](assets/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/image-20220714222531080.png)

### 4. 活动图（流程图）

#### 4.1 流程图

​	![image-20220714223947926](assets/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/image-20220714223947926.png)

#### 4.1 泳道图

1. 表示两个系统之间的关系

   ![image-20220714224459269](assets/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/image-20220714224459269.png)

### 5. 状态图

#### 5.1 基本概念

1. 通过建立对象的生存周期模型来描述对象随时间变化的动态行为

#### 案例

1. 练习

   - 创建(新建)
   - 就绪
   - 运行
   - 阻塞
   - 消亡

2. 答案

   ![image-20220714232250050](assets/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/image-20220714232250050.png)

### 6. 协作图

#### 基本概念

1. 表示对象间交互的过程

   ![image-20220714232503245](assets/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/image-20220714232503245.png)

   ![image-20220714232520677](assets/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/image-20220714232520677.png)

### 7. 包图

#### 7.1 基本概念

1. 表示各个组件之间的关系

   ![image-20220714232743496](assets/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/image-20220714232743496.png)

   ![image-20220714232735593](assets/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/image-20220714232735593.png)

   - 包没有实例

### 8. 组件图

#### 8.1 基本概念

1. 表示各个组件之间的关系，可以用来设计系统的整体架构

   - 虚线表示依赖

   ![image-20220714232928311](assets/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/image-20220714232928311.png)

### 8. 部署图

#### 基本概念

1. 表示软件各个组件驻留在什么硬件位置，以及这些硬件之间的交互关系。

2. 节点：用来表示一种硬件，可以是打印机、计算机等。

   - 符号：三维框，框的左上方包含节点的名称
   - 通信关联：节点通过通信关联建立彼此的关系，采用节点到节点绘制实线表示关联

   ![image-20220714233453141](assets/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/image-20220714233453141.png)

   ![image-20220714233852460](assets/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/image-20220714233852460.png)

## 设计模式

### 1. 基本原则

#### 1.1 前言

1. 模式：固定的套路解决问题
   - 初学者要记案例
2. 设计模式：软件工程的基础脉络
   - 基础：多态
3. 三大类型：
   - 创建型
     - 用于创建对象
   - 结构型
   - 行为型
4. 学习设计模式的意义
   - 提高职业素养

#### 1.2 设计模式基本原则

- **开闭原则**

  ![image-20220714235255260](assets/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/image-20220714235255260.png)

  ~~~C++
  // 繁忙的业务员
  class BankWorker{
  public:
  	void save(){
          cout << "存款" << endl;
      }    
      void moveM(){
          cout << "转账" << endl;
      }    
      void jiaofei(){
          cout << "缴费" << endl;
      }    
  }
  
  void test0()
  {
      BankWorker *bw = new BankWorker();
      bw->jiaofei();
      bw->save();
      bw->moveM();
  }
  
  // 轻松额业务员
  class AvBankWorker{
  public:
      virtual void dothing() = 0;
  }
  
  class SaveBanker : public AvBankWorker
  {
  	virtual void dothing()
      {
          cout << "存款" << endl; 
      }
  }
  
  class MoveBanker : public AvBankWorker
  {
  	virtual void dothing()
      {
          cout << "转账" << endl; 
      }
  }
  
  void test1(){
      AvBankWorker *sb = new SaveBanker();
   	AvBankWorker *bw = new MoveBanker();
      sb->doting();
      bw->doting();
      delete sb;
      delete bw;
  }
  
  // 框架函数
  void howDo(AbBankWorker *bw)
  {
      bw->dothing();
  }
  
  int main(){
      //test0();
      test1();
      return 0;
  }
  ~~~

  

- 单依职责原则

- **依赖倒置原则**

  - 依赖抽象，不依赖具体的实现，也就是针对接口编程。

    传统：![image-20220716110513578](assets/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/image-20220716110513578.png)

    好的设计模式：

    ![image-20220716110525770](assets/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/image-20220716110525770.png)
    
    ```C++
    class HardDisk
    {
    public:
        virtual void work() = 0;
    };
    
    class Memory
    {
    public:
        virtual void work() = 0;
    };
    
    class Cpu
    {
    public:
        virtual void work() = 0;
    };
    
    class XSDisk : public HardDisk
    {
    public:
        void work() override
        {
            std::cout << "XSDisk work" << std::endl; 
        }
    };
    
    class JSMem : public Memory
    {
    public:
        void work() override
        {
            std::cout << "JSMem work" << std::endl; 
        }
    };
    
    class InterCpu : public Cpu
    {
    public:
        void work() override
        {
            std::cout << "InterCpu work" << std::endl; 
        }
    };
    
    class Computer
    {
    public:
        Computer(HardDisk *hardDisk, Memory *memory, Cpu *cpu)
            : m_hardDisk(hardDisk)
            , m_memory(memory)
            , m_cpu(cpu)
            {}
        
    public:
      	void work()
        {
            m_hardDisk->work();
            m_memory->work();
            m_cpu->work();
        }
        
    private:
        HardDisk *m_hardDisk;
        Memory *m_memory;
        Cpu *m_cpu;
    };
    
    void test0
    {
        HardDisk *hardDisk = new XSDisk();
        Memory *memory = new JSMem();
        Cpu *cpu = new InterCpu();
        
        Computer *computer = new Computer(hardDisk, memory, cpu);
        
        computer->work();
        
        delete hardDisk;
        delete memory;
        delete cpu;
        delete computer;
    }
    ```
    
    

- 接口隔离原则

  - 不应该迫使客户额度程序依赖他们不需要的接口方法，一个接口只提供一种对外功能，不应该把所有的操作都封装到一个接口中去。

- 里式替换原则

  - 任何抽象类出现的地方都可以用它的子类替换，即可以用子类对象初始化父类对象

- 优先使用组合而不是继承

  - 例如类A要增加一个方法

    ```C++
    class A
    {
    public:
        void doA()
        {
            
        }
        // 方法一
        void doB()
        {
            
        }
    };
    
    // 方法二
    class B : public A
    {
    public:
        void doB()
        {
            
        }  
    };
    
    // 方法三
    class C
    {
    public:
        C(A *a)
            : m_a(a)
            {}
        
    private:
        A *m_a;
    };
    
    // 方法四
    // java aop编程（面向切面编程）
    // 例如在A方法中doA前后都加日志
    ```

    

- **迪米特法则**

  - 一个对象尽可能的少了解其他对象

  - 和陌生人说话（不安全）

    ![image-20220716160445777](assets/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/image-20220716160445777.png)

  - 不喝陌生人说话

    ![image-20220716160451381](assets/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/image-20220716160451381.png)

  - 与依赖倒置原则结合，让某人和抽象陌生人说话，让某人和陌生人进行解耦合（控制风险）

    ![image-20220716160613906](assets/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/image-20220716160613906.png)

### 2 创建型模式

#### 2.1 单例模式

##### 2.1.1 概念

- 保证一个类只有一个实体存在，同时提供能对该实例加以访问的全局方法。

- ![image-20220716161142224](assets/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/image-20220716161142224.png)

##### 2.1.2 为什么使用单例模式

- 多线程之间只用一个socket资源
- 在整个程序中使用全局变量，共享资源
- 在大规模系统中，提高性能

##### 2.1.3 实现单例步骤

1. 构造函数私有化
2. 提供一个全局静态方法
3. 在类中定义一个静态指针，只想本类变量额度静态变量指针

##### 2.1.4 饿汉单例和懒汉单例

- 懒汉式

  - 只有在使用的时候，才会去创建实例
    - 缺点：
      - 每次get都要判断
      - 多线程存在问题

  ~~~C++
  class Singelton
  {
  public:
      static Singelton* getInstance()
      {
          if(m_psl == nullptr){
              m_psl = new Singelton;
          }
          return m_psl;
      }
      
      static Singelton* freeInstance()
      {
          if(m_psl){
              delete m_psl;
              m_psl = nullptr;
          }
          return m_psl;
      }
      
  private:
  	Singelton()
      {
          std::cout << "Singelton()" << std::endl;
      }
      
  private:
      static Singelton *m_psl;
  };
  
  Singelton *Singelton::m_spl = nulptr;
  void test0()
  {
      Singelton *p1 = Singelton::getInstance();
      Singelton *p2 = Singelton::getInstance();
  	if(p1 == p2){
          std::cout << "is same" << std::endl;
      }
      else{
          std::cout << "no same" << std::endl;
      }
      Singleton::freeInstance();
  }
  ~~~

- 饿汉式

  - 一开始就创建实例
  - 缺点：
    - 不用的时候也new'，浪费内存。

  ~~~shell
  class Singelton
  {
  public:
      static Singelton* getInstance()
      {
          return m_psl;
      }
      
      static Singelton* freeInstance()
      {
          if(m_psl){
              delete m_psl;
              m_psl = nullptr;
          }
          return m_psl;
      }
      
  private:
  	Singelton()
      {
          std::cout << "Singelton()" << std::endl;
      }
      
  private:
      static Singelton *m_psl;
  };
  
  Singelton *Singelton::m_spl = new Singelton();
  void test0()
  {
      Singelton *p1 = Singelton::getInstance();
      Singelton *p2 = Singelton::getInstance();
  	if(p1 == p2){
          std::cout << "is same" << std::endl;
      }
      else{
          std::cout << "no same" << std::endl;
      }
      Singleton::freeInstance();
  }
  ~~~

- 多线程遇上懒汉时会出问题，饿汉时不会。

  - 多进程1次调用，2次返回

  - 构造函数不是线程安全函数

  - 临界区（同步线程）

    ![image-20220716195420059](assets/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/image-20220716195420059.png)

  - 互斥量（同步进程、线程）

    ![image-20220716195437206](assets/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/image-20220716195437206.png)

  - 懒汉多线程优化，**双检查锁**

    ~~~C++
    static Singelton* getInstance()
    {
        if(m_psl == nullptr){
            m_lock.lock();
            if(m_psl == nullptr){
                m_psl = new Singelton;
        	}
            m_lock.unlock();
        }
    
        return m_psl;
    }
    ~~~



#### 2.2 简单工厂模式

##### 2.2.1 什么是简单工程模式

- 又叫静态工厂方法模式，通过一个类创建其他类

##### 2.2.2 模式中包含的角色及职责

- 工厂

  - 负责生产产品

- 抽象角色

  - 公共接口

- 具体产品

  - 创建的具体实例

  ![image-20220716203139428](assets/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/image-20220716203139428.png)

  

- 优缺点

  - 优点
  - 缺点
    - 高内聚做的不好，不符合开闭原则，不是标准设计模式

- 代码 

  ~~~C++
  class Fruit
  {
  public:
  	virtual void getFruit() = 0;
  };
  
  class Banana : public Fruit
  {
  public:
      virtual void getFruit() override
      {
  		std::cout << "I am banana" << std::endl;
      }
  };
  
  class Apple : public Fruit
  {
  public:
      virtual void getFruit() override
      {
  		std::cout << "I am apple" << std::endl;
      }
  };
  
  class Factory
  {
  public:
  	Fruit* create(const char *p)
      {
  		if(strcmp(p, "banana") == 0){
              return new Banana();
          }
          else if(strcmp(p, "apple") == 0){
              return new Apple();
          }
          else{
              std::cout << "No type Fruit" << std::endl;
          }
      }
  };
  ~~~

  

#### 2.3 工厂模式

##### 2.3.1 概念

- 实现了 client 与 具体产品 具体工厂的解耦合

##### 2.3.2 类图角色和职责

- 类图

  ![image-20220716210811883](assets/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/image-20220716210811883.png)

##### 2.3.3 代码

~~~C++
class Fruit
{
public:
	virtual void sayName() = 0;
};

class Banana : public Fruit
{
public:
    virtual void sayName() override
    {
		std::cout << "I am banana" << std::endl;
    }
};

class Apple : public Fruit
{
public:
    virtual void sayName() override
    {
		std::cout << "I am apple" << std::endl;
    }
};

class AbFactory
{
public:
	virtual Fruit* createProduct() = 0;
};

class BananaFactory : public AbFactory
{
    virtual Fruit* createProduct() override
    {
        return new Banana();
    }
};

class AppleFactory : public AbFactory
{
    virtual Fruit* createProduct() override
    {
        return new Apple();
    }
};

void test0()
{
    AbFactory *f = nullptr;
    Fruit *fruit = nullptr;

    f = new BananaFactory();
    fruit = f->createProduct();
    fruit->sayName();

    delete f;
    delete fruit;

    f = new AppleFactory();
    fruit = f->createProduct();
    fruit->sayName();

    delete f;
    delete fruit;
}
~~~

- C++ 多态的实现和 C 语言通过传递地址改变参数一一对应

#### 2.4 抽象工厂模式

##### 2.4.1 概念

- 在开闭的原则下，能生产一批产品

- 工厂模式的缺点
  - 只能生产一个产品
- 抽象工厂缺点
  - 产品线是写死的

![image-20220716213327305](assets/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/image-20220716213327305.png)

##### 2.4.2 模式中包含的角色及其职责

- 抽象工厂
- 具体工厂
- 抽象角色
- 具体角色

![image-20220716213432432](assets/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/image-20220716213432432.png)

##### 2.4.3 代码

~~~C++
class Fruit
{
public:
	virtual void sayName() = 0;
};

class AbFruitFactory
{
public:
    virtual Fruit* createBanana() = 0;
    virtual Fruit* createApple() = 0;
};

class NorthBanana : public Fruit
{
public:
    virtual void sayName() override
    {
		std::cout << "I am NorthBanana" << std::endl;
    }
};

class NorthApple : public Fruit
{
public:
    virtual void sayName() override
    {
		std::cout << "I am NorthApple" << std::endl;
    }
};

class SourthBanana : public Fruit
{
public:
    virtual void sayName() override
    {
		std::cout << "I am SourthBanana" << std::endl;
    }
};

class SourthApple : public Fruit
{
public:
    virtual void sayName() override
    {
		std::cout << "I am SourthApple" << std::endl;
    }
};

class NorthFruitFactory : public AbFruitFactory
{
public:
    virtual Fruit* createBanana() override
    {
        return new NorthBanana();
    }

    virtual Fruit* createApple() override
    {
        return new NorthApple();
    }
};

class SourthFruitFactory : public AbFruitFactory
{
public:
    virtual Fruit* createBanana() override
    {
        return new SourthBanana();
    }

    virtual Fruit* createApple() override
    {
        return new SourthApple();
    }
};

void test0()
{
	AbFruitFactory *ff = nullptr;
    Fruit *fruit = nullptr;
    
    ff = new SourthFruitFactory();
    fruit = ff->createBanana();
    fruit->sayName();
    fruit = ff->createApple();
    fruit->sayName();   
    
    delete ff;
    delete fruit;
    
    ff = new NorthFruitFactory();
    fruit = ff->createBanana();
    fruit->sayName();
    fruit = ff->createApple();
    fruit->sayName();   
    
    delete ff;
    delete fruit;
}
~~~



#### 2.5 建造者模式

##### 2.5.1 概念

-  对象的构建比较复杂，将一个对象的构建和对象的表示进行分离

##### 2.5.2 角色和职责

![image-20220716231859705](assets/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/image-20220716231859705.png)

- director
  - 设计师，指挥工程队干活

- builder
  - 为创建产品的各个部分，抽象接口
  - 抽象工程队
- concreateBuilder
  - 具体工程队

##### 2.5.3 创建者模式和工厂模式的区别

- 客户直接造房子不好
- 工程队直接造房子，不好-新需求需要变化

##### 2.5.4 案例

~~~C++
 class House
{
public:
    void setDoor(const string &door)
    {
        m_door = door;
    }

    void setWall(const string &wall)
    {
        m_wall = wall;
    }

    void setWindow(const string &window)
    {
        m_window = window;
    }

    void print()
    {
        std::cout << "door:" << m_door << " wall:" 
                  << m_door << " window:" << m_window 
                  << std::endl;  
    }

private:
    string m_door;
    string m_wall;
    string m_window;
};

class Builder
{
public:
    virtual void buildWall() = 0;
    virtual void buildDoor() = 0;
    virtual void buildWindow() = 0;
    virtual House* getHouse() = 0;
};

// 公寓工程队
class FlatBuilder : public Builder
{
public:
    FlatBuilder()
    {
        m_pHouse = new House();
    }

    virtual void buildWall() override
    {
        m_pHouse->setWall("flat wall");
    }

    virtual void buildDoor() override
    {
        m_pHouse->setDoor("flat door");
    }

    virtual void buildWindow() override
    {
        m_pHouse->setWindow("flat window");
    }

    virtual House* getHouse() override
    {
        return m_pHouse;
    }

private:
    House *m_pHouse;
};

// 别墅工程队
class VillaBuilder : public Builder
{
public:
    VillaBuilder()
    {
        m_pHouse = new House();
    }

    virtual void buildWall() override
    {
        m_pHouse->setWall("villa wall");
    }

    virtual void buildDoor() override
    {
        m_pHouse->setDoor("villa door");
    }

    virtual void buildWindow() override
    {
        m_pHouse->setWindow("villa window");
    }

    virtual House* getHouse() override
    {
        return m_pHouse;
    }

private:
    House *m_pHouse;
};

// 设计师（指挥者）负责建造逻辑
// 建筑队 负责干具体的活
class Director
{
public:
    Director(Builder *builder)
        : m_builder(builder)
    {}

    void construct()
    {   
        m_builder->buildWall();
        m_builder->buildWindow();
        m_builder->buildDoor();
    }

private:
    Builder *m_builder;
};

void test0()
{
    Builder *builder = new VillaBuilder();
    Director *director = new Director(builder);
    director->construct();
    House *house = builder->getHouse();
    house->print();

    delete builder;
    delete director;
    
    builder = new FlatBuilder();
    director = new Director(builder);
    director->construct();
    house = builder->getHouse();
    house->print();

    delete builder;
    delete director;
}
~~~



#### 2.6 原型模式prototype

##### 2.6.1 概念

- 为每一个对象提供一个接口，让一个复杂对象具有自我复制的功能。
- 类似于拷贝构造函数
- 涉及问题
  - 深拷贝浅拷贝

##### 2.6.2 类图

![image-20220717123453366](assets/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/image-20220717123453366.png)

##### 2.6.3 代码实现

~~~C++
class Person
{
public:
    virtual Person* clone() = 0;
    virtual void print() = 0;
    virtual ~Person(){}
};

class CPPWorker : public Person
{
public:
    CPPWorker()
    : m_name("")
    , m_age(0)
    , m_resume(nullptr)
    {
        setResume("aaaa");
    }

    CPPWorker(string name, int age)
    : m_name(name)
    , m_age(age)
    , m_resume(nullptr)
    {
        setResume("aaaa");
    }

    ~CPPWorker()
    {
        if(m_resume){
            delete m_resume;
            m_resume = nullptr;
        }
    }

    void setResume(const char *p)
    {
        if(m_resume && m_resume != p){
            delete m_resume;
        }
        m_resume = new char[strlen(p) + 1];
        strcpy(m_resume, p); 

    }

    virtual void print() override
    {
        cout << "name:" << m_name << " age:" << m_age << " resume:" << m_resume << " addr:" << &m_resume << endl;
    }

    virtual Person* clone() override
    {
        CPPWorker *res = new CPPWorker();
        *res = *this;  // 默认浅拷贝
        res->setResume(m_resume);
        return res;
    }

private:
    string m_name;
    int m_age;
    char *m_resume;
};

void test0()
{
    Person *p1 = new CPPWorker("zhangsan", 18);
    p1->print();
    Person *p2 = p1->clone();
    delete p1;
    p2->print();
}
~~~



### 3 结构型模式

- 让类和类之间组合获得更大的结构

#### 3.1 ==代理模式==

##### 3.1.1 概念

- 自己打游戏累了，找别人代打
- A（代理）包含B类（一般），B实现协议类Protocol
- 适用于
  - 为其他对象提供一只代理，以控制对这个对象的访问

##### 3.1.2 类图

- proxy 代理
- realSubject 玩家

![image-20220717124521409](assets/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/image-20220717124521409.png)

##### 3.1.3 代码实现

~~~C++
class Subject
{
public:
    virtual void sailBook() = 0;
};

class RealSubjectBook : public Subject
{
public:
    virtual void sailBook() override
    {
        cout << "sail book" << endl;
    }
};

class DangdangProxy : public Subject
{
public:
    virtual void sailBook() override
    {
        RealSubjectBook *rsb = new RealSubjectBook();
        dazhe();
        rsb->sailBook();
        dazhe();
    }

    void dazhe()
    {
        cout << "11.11 50%" << endl;
    }

private:
    Subject *m_subject;
};

void test0(){
    Subject *s = new DangdangProxy();
    s->sailBook();
}
~~~



#### 3.2 ==装饰模式==

##### 3.2.1 基本概念

- 有一个类A，对类A进行功能性增强
- 适用于
  - 动态的给一个对象添加一个额外的功能，且添加的额外的功能可以自由的组合

##### 3.2.2 类图及职责

![image-20220717130836564](assets/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/image-20220717130836564.png)

##### 3.3.3 代码实现

~~~C++
class Car
{
public:
    virtual void show() = 0;
};

class RunCar : public Car
{
public:
    virtual void show() override
    {
        cout << "run car" << endl;
    }
};

class SwimCarDirector : public Car
{
public:
    SwimCarDirector(Car *car)
    : m_car(car)
    {}

    virtual void show() override
    {
        m_car->show();
        swim();
    }

private:
    void swim()
    {
        cout << "swim" << endl;
    }

private:
    Car *m_car;
};

class FlyCarDirector : public Car
{
public:
    FlyCarDirector(Car *car)
    : m_car(car)
    {}

    virtual void show() override
    {
        m_car->show();
        swim();
    }

private:
    void swim()
    {
        cout << "fly" << endl;
    }

private:
    Car *m_car;
};

void test0(){
    Car *car0 = new RunCar();
    car0->show();
    
    Car *car1 = new SwimCarDirector(car0);
    car1->show();

    Car *car2 = new FlyCarDirector(car1);
    car2->show();

    delete car0;
    delete car1;
    delete car2;
}
~~~



#### 3.3 ==适配器模式adapter==

##### 3.3.1 基本概念

- 将一个类的接口转换成客户希望的另外一个接口，使原本由于接口不兼容而不能一起工作的那些类可以一起工作 

##### 3.3.2 类图及职责

![image-20220717151918967](assets/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/image-20220717151918967.png)

##### 3.3.3 代码实现

~~~C++
class Current18V
{
public:
    virtual void useCurrent18V() = 0; 
};

class Current220V
{
public:
    void useCurrent220V()
    {
        cout << "My ele is 220V" << endl;
    }
};

class Adapter : public Current18V
{
public:
    Adapter(Current220V *current220V)
    : m_current220V(current220V)
    {}

    virtual void useCurrent18V() override
    {
        m_current220V->useCurrent220V();
        cout << "My ele is 18V currently" << endl;
    }

private:
    Current220V *m_current220V;
};

void test0(){
    Current220V *current220V = new Current220V();
    Adapter *adapter = new Adapter(current220V);
    adapter->useCurrent18V();
}
~~~



#### 3.4 组合模式

##### 3.4.1 基本概念

- 单一对象和组合对象使用一致的接口，将对象组合成树形结构以表示“部分-整体”

##### 3.4.2 类图及职责

![image-20220717160520099](assets/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/image-20220717160520099.png)

##### 3.4.3 代码实现

~~~C++
class IFile
{
public:
    virtual ~IFile(){}
    virtual void display() = 0;
    virtual int add(IFile *iFile) = 0;
    virtual int remove(IFile *iFile) = 0;
    virtual list<IFile*>* getChild() = 0;
};

class File : public IFile
{
public:
    File(const string &name)
    : m_name(name)
    {}

    virtual void display() override
    {
        cout << m_name << endl;
    }
    virtual int add(IFile *iFile) override
    {
        return -1;
    }

    virtual int remove(IFile *iFile) override
    {
        return -1;
    }

    virtual list<IFile*>* getChild() override
    {
        return nullptr;
    }

private:
    string m_name;
};

class Dir : public IFile
{
public:
    Dir(const string &name)
    : m_name(name)
    , m_list(new list<IFile*>())
    {
        m_list->clear();
    }

    ~Dir()
    {
        delete m_list;
    }

    virtual void display() override
    {
        cout << m_name << endl;
        // for(IFile *iFile: *m_list){
        //     iFile->display();
        // }
    }
    virtual int add(IFile *iFile) override
    {
        m_list->push_back(iFile);
        return -1;
    }

    virtual int remove(IFile *iFile) override
    {
        m_list->remove(iFile);
        return -1;
    }

    virtual list<IFile*>* getChild() override
    {
        return m_list;
    }

private:
    string m_name;
    list<IFile*> *m_list;
};

// 递归的显示树
void showTree(IFile *root, int count)
{
    if(root == nullptr){
        return;
    }
    for(int i = 0; i < count; ++i){
        printf("\t");
    }
    root->display();
    list<IFile*> *list = root->getChild();
    if(list){
        for(IFile* iFile: *list){
            if(iFile->getChild() == nullptr){
                for(int i = 0; i<=count; ++i){
                    printf("\t");
                }
                iFile->display();
            }
            else{
                showTree(iFile, ++count);
            }
        }
    }
}

void test0(){
    Dir *root = new Dir("C");
    Dir *dir1 = new Dir("111dir");
    Dir *dir2 = new Dir("222dir");
    File *file2 = new File("bbb.txt");
    dir1->add(dir2);
    dir1->add(file2);
    File *file1 = new File("aaa.txt");
    root->add(dir1);
    root->add(file1);
    showTree(root, 0);
}
~~~



#### 3.5 ==桥接模式bridge==

##### 3.5.1 基本概念

- 将抽象模式与实现部分分离，使他们都可以独立发生变化

![image-20220717154523870](assets/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/image-20220717154523870.png)

![image-20220717154529786](assets/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/image-20220717154529786.png)

##### 3.5.2 类图及职责

![image-20220717153150561](assets/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/image-20220717153150561.png)

##### 3.5.3 代码实现

~~~C++
class Engine
{
public:
    virtual void InstallEngine() = 0;
};

class Engine4400cc : public Engine
{
public:
    virtual void InstallEngine()
    {
        cout << "I am 4400" << endl;
    }
};

class Engine4500cc : public Engine
{
public:
    virtual void InstallEngine()
    {
        cout << "I am 4500" << endl;
    }
};

class Car
{
public:
    Car(Engine *engine)
    : m_engine(engine)
    {}

    virtual void installEngine() = 0;

protected:
    Engine *m_engine;
};

class BMA5 : public Car
{
public:
    BMA5(Engine *engine)
    : Car(engine)
    {}

    virtual void installEngine() override
    {
        cout << "I am BMA5" << endl;
        m_engine->InstallEngine();
    }
};

class BMA6 : public Car
{
public:
    BMA6(Engine *engine)
    : Car(engine)
    {}

    virtual void installEngine() override
    {
        cout << "I am BMA6" << endl;
        m_engine->InstallEngine();
    }
};

void test0(){
    Engine *engine = new Engine4400cc();
    Car *car = new BMA5(engine);
    car->installEngine();
    delete engine;
    delete car;
}
~~~



#### 3.6 外观模式

##### 3.6.1 基本概念

- 为一组具有功能相似的类群，如类库、子系统等，提供一个一致的简单的界面，这个一致简单界面被称作facade

##### 3.6.2 类图及职责

![image-20220717173814974](assets/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/image-20220717173814974.png)

##### 3.6.3 代码实现

~~~C++
class SubSystemA
{
public:
    void dothing()
    {
        cout << "SubsystemA run" << endl;
    }
};

class SubSystemB
{
public:
    void dothing()
    {
        cout << "SubSystemB run" << endl;
    }
};

class SubSystemC
{
public:
    void dothing()
    {
        cout << "SubSystemC run" << endl;
    }
};

class Facade
{
public:
    Facade()
    : m_subSystemA(new SubSystemA())
    , m_subSystemB(new SubSystemB())
    , m_subSystemC(new SubSystemC())
    {}

    ~Facade()
    {
        delete m_subSystemA;
        delete m_subSystemB;
        delete m_subSystemC;
    }

    void doting()
    {
        m_subSystemA->dothing();
        m_subSystemB->dothing();
        m_subSystemC->dothing();
    }

private:
    SubSystemA *m_subSystemA;
    SubSystemB *m_subSystemB;
    SubSystemC *m_subSystemC;
};

void test0(){
    Facade *f = new Facade();
    f->doting();
}

~~~



#### 3.7 享元模式

##### 3.7.1 基本概念

- 一个同样的对象只生产一份
- 以共享的方式，高效的支持大量的细粒度的对象

##### 3.7.2 类图及职责

- 抽象享元角色
  - 公共接口
- 具体享元角色
  - 抽象接口的具体实现
- 享元工厂角色
  - 创建享元角色

![image-20220717183815732](assets/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/image-20220717183815732.png)

##### 3.7.3 代码实现

~~~C++
class Person
{
public:
    Person(string name, int age)
    : m_name(name)
    , m_age(age)
    {}

    virtual void print() = 0;

protected:
    string m_name;
    int m_age;
};

class Teacher : public Person
{
public:
    Teacher(string name, int age, string id)
    : Person(name, age)
    , m_id(id)
    {}

    void print() override
    {
        cout << "name:" << m_name
             << " age:" << m_age
             << " id:" << m_id << endl; 
    }

private:
    string m_id;
};

class FlyWeighTeacherFactory
{
public:
    FlyWeighTeacherFactory()
    {
        m_map.clear();
    }

    ~FlyWeighTeacherFactory()
    {
        while(!m_map.empty()){
            auto it = m_map.begin();
            Person *tmp = it->second;
            m_map.erase(it);
            delete tmp;
            tmp = nullptr;
        }
    }

    Person* getTeacher(string id)
    {
        
        auto res = m_map.find(id);
        if(res == m_map.end()){
            string name;
            int age;
            cout << "\nplease input name" << endl;
            cin >> name;
            cout << "\nplease input age" << endl;
            cin >> age;
            Teacher *tmp = new Teacher(name, age, id);
            m_map.insert(make_pair(id, tmp));
            return tmp;
        }
        else{
            return res->second;
        }
    }
    
private:
    map<string, Person*> m_map;
};

void test0(){
    FlyWeighTeacherFactory *fwtf = new FlyWeighTeacherFactory();
    Person *p1 = fwtf->getTeacher("001");
    p1->print();

    Person *p2 = fwtf->getTeacher("001");
    p2->print();

    delete fwtf;
}
~~~



### 4 行为型模式

- 用来对类或对象之间怎么交互，怎么样分配职责进行描述

#### 4.1 模板模式

##### 4.1.1 基本概念

- 在抽象类中统一操作步骤，并规定好接口，让子类实现接口，这样可以把各个具体的子类和操作步骤解耦

##### 4.1.2 类图及职责

- AbstractClass
  - 抽象父类
- ConcreteClass
  - 具体实现的子类
- templateMethod
  - 模板方法
- method1与mothod2
  - 具体的步骤方法

![image-20220717210726891](assets/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/image-20220717210726891.png)

##### 4.1.3 代码实现

~~~C++
class MakeCar
{
public:
    virtual void makeHead() = 0;
    virtual void makeBody() = 0;
    virtual void makeTail() = 0;

    void make()
    {
        makeTail();
        makeBody();
        makeHead();
    }
};

class Jeep : public MakeCar
{
public:
    virtual void makeHead() override
    {
        cout << "jeep head" << endl;
    }

    virtual void makeBody() override
    {
        cout << "jeep body" << endl;
    }

    virtual void makeTail() override
    {
        cout << "jeep tauk" << endl;
    }
};

class Bus : public MakeCar
{
public:
    virtual void makeHead() override
    {
        cout << "bus head" << endl;
    }

    virtual void makeBody() override
    {
        cout << "bus body" << endl;
    }

    virtual void makeTail() override
    {
        cout << "bus tauk" << endl;
    }
};

void test0(){
    MakeCar *car = new Bus();
    car->make();
    delete car;

    car = new Jeep();
    car->make();
    delete car;
}
~~~



#### 4.2 命令模式

##### 3.2.1 基本概念

- 在面向对象程序设计中，一个对象调用另外一个对象，现在通过一个command类来调用另一个对象

- 将一个请求封装成一个对象，从而使你可用不同的请求对客户端进行参数化，对请求排队或记录请求日志，以及支持可撤销的操作

##### 3.2.2 类图及职责

- 

![image-20220717211636821](assets/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/image-20220717211636821.png)

##### 3.3.3 代码实现

~~~C++
class Doctor
{
public:
    void treat_eye()
    {
        cout << "doctor treat eye" << endl;
    }

    void treat_nose()
    {
        cout << "doctor treat nose" << endl;
    }
};

class Command
{
public:
    virtual void treat() = 0;
};

class CommandTreatEye : public Command
{
public:
    CommandTreatEye(Doctor *doctor)
    : m_doctor(doctor)
    {}

    void treat() override
    {
        m_doctor->treat_eye();
    }

private:
    Doctor *m_doctor;
};

class CommandTreatNose : public Command
{
public:
    CommandTreatNose(Doctor *doctor)
    : m_doctor(doctor)
    {}

    void treat() override
    {
        m_doctor->treat_nose();
    }

private:
    Doctor *m_doctor;
};

class BeautyNurse
{
public:
    BeautyNurse(Command *command)
    :m_command(command)
    {}

    void SubmittedCase()
    {
        m_command->treat();
    }

private:    
    Command *m_command;
};

class AdvHeadNurse
{
public:
    AdvHeadNurse()
    {
        m_commands.clear();
    }

    ~AdvHeadNurse()
    {
        for(auto it = m_commands.begin(); it != m_commands.end(); ++it) {
            delete (*it);
        }
    }

    void setCommand(Command *command)
    {
        m_commands.push_back(command);
    }

    void SubmittedCase()
    {
        for(auto it = m_commands.begin(); it != m_commands.end(); ++it) {
            (*it)->treat();
        }
    }

private:    
    list<Command*> m_commands;
};


void test0()
{
    Doctor *doctor = new Doctor();
    doctor->treat_eye();
    doctor->treat_nose();
    delete doctor;  
}

void test1()
{
    Doctor *doctor = new Doctor();
    Command *command = new CommandTreatEye(doctor);
    command->treat();
    delete command;
    command = new CommandTreatNose(doctor);
    command->treat();
    delete doctor;
    delete command;
}

void test2()
{
    Doctor *doctor = new Doctor();
    // Command *command = new CommandTreatEye(doctor);
    Command *command = new CommandTreatNose(doctor);
    BeautyNurse *beautyNurse = new BeautyNurse(command);
    beautyNurse->SubmittedCase();

    delete doctor;
    delete command;
    delete beautyNurse;
}

void test3()
{
    Doctor *doctor = new Doctor();
    AdvHeadNurse *headNurse = new AdvHeadNurse();
    headNurse->setCommand(new CommandTreatNose(doctor));
    headNurse->setCommand(new CommandTreatEye(doctor));
    headNurse->setCommand(new CommandTreatNose(doctor));
    headNurse->setCommand(new CommandTreatEye(doctor));
    headNurse->SubmittedCase();
    delete doctor;
    delete headNurse;
}
~~~



#### 4.3 责任链模式

##### 3.2.1 基本概念

- 链条式完成任务
  - A().B().C().D()

##### 3.2.2 类图及职责

![image-20220717221203841](assets/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/image-20220717221203841.png)

##### 3.3.3 代码实现

~~~C++
struct Teacher
{
    char name;
    int age;
    Teacher *next;
};

class CarHandle
{
public:
    virtual void HandleCar() = 0;
    CarHandle* setNextHandle(CarHandle *carHandle)
    {
        m_carHandle = carHandle;
        return m_carHandle;
    }

protected:
    CarHandle *m_carHandle;  // 下一个处理单元
};

class HeadCarHandel : public CarHandle
{
public:
    virtual void HandleCar() override
    {
        cout << "make head" << endl;
        if(m_carHandle){
            m_carHandle->HandleCar();
        }
    }
};

class BodyCarHandel : public CarHandle
{
public:
    virtual void HandleCar() override
    {
        cout << "make body" << endl;
        if(m_carHandle){
            m_carHandle->HandleCar();
        }
    }
};

class TailCarHandel : public CarHandle
{
public:
    virtual void HandleCar() override
    {
        cout << "make Tail" << endl;
        if(m_carHandle){
            m_carHandle->HandleCar();
        }
    }
};

void test0(){
    CarHandle *headHandle = new HeadCarHandel();
    CarHandle *bodyHandle = new BodyCarHandel();
    CarHandle *tailHandle = new TailCarHandel();

    headHandle->HandleCar();
    bodyHandle->HandleCar();
    tailHandle->HandleCar();

    delete headHandle;
    delete bodyHandle;
    delete tailHandle;
}

void test1()
{
    CarHandle *headHandle = new HeadCarHandel();
    CarHandle *bodyHandle = new BodyCarHandel();
    CarHandle *tailHandle = new TailCarHandel();

    headHandle->setNextHandle(bodyHandle);
    bodyHandle->setNextHandle(tailHandle);
    tailHandle->setNextHandle(nullptr);
    headHandle->HandleCar();

    delete headHandle;
    delete bodyHandle;
    delete tailHandle;
}
~~~



#### 4.4 策略模式

##### 3.2.1 基本概念

##### 3.2.2 类图及职责

- Strategy
  - 抽象策略
- ConcreteStrategy
  - 具体策略
- Context
  - 策略的容器，根据不同的策略执行不同的行为

![image-20220717230725154](assets/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/image-20220717230725154.png)

##### 3.3.3 代码实现

~~~C++
class Strategy
{
public:
    virtual void crypt() = 0;
};

class AES : public Strategy
{
public:
    virtual void crypt() override
    {
        cout << "AES crypt" << endl;
    }
};

class DES : public Strategy
{
public:
    virtual void crypt() override
    {
        cout << "DES crypt" << endl;
    }
};

class Context
{
public:
    void setStrategy(Strategy *strategy)
    {
        m_strategy = strategy;
    }

    void myOperator()
    {
        m_strategy->crypt();
    }

private:
    Strategy *m_strategy;
};

void test0()
{
    Strategy *des = new DES();
    Strategy *aes = new AES();
    Context *context = new Context();
    context->setStrategy(des);
    context->myOperator();
    context->setStrategy(aes);
    context->myOperator();
    delete des;
    delete aes;
    delete context;
}
~~~



#### 4.5 中介者模式 

##### 3.2.1 基本概念

- 适用于
  - 用一个中介对象，封装一系列对象（同事）的交换，中介者是各个对象不需要显示的相互作用，从而实现了耦合松散，而且可以独立改变他们之间的交换

##### 3.2.2 类图及职责

![image-20220717232901107](assets/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/image-20220717232901107.png)

##### 3.3.3 代码实现

~~~c++
class Mediator;

class Person
{
public:
    Person(string name, int sex, int condi, Mediator *mediator)
    : m_name(name)
    , m_sex(sex)
    , m_condi(condi)
    , m_mediator(mediator)
    {}

    int getCondi()
    {
        return m_condi;
    }

    int getSex()
    {
        return m_sex;
    }

    string getName()
    {
        return m_name;
    }

    virtual void getParter(Person *person) = 0;

protected:
    string m_name;
    int m_sex;
    int m_condi;
    Mediator *m_mediator;
};

class Mediator
{
public:
    void setMan(Person *p)
    {
        m_pMan = p;
    }

    void setWoman(Person *p)
    {
        m_pWoman = p;
    }

    void getParter(){
        if(m_pMan->getSex() == m_pWoman->getSex()){
            cout << "I am not same sex" << endl;
            return;
        }
        if(m_pMan->getCondi() == m_pWoman->getCondi()){
            cout << m_pMan->getName() << " and " << m_pWoman->getName() << " are very good!" << endl;        
        }
        else{
            cout << m_pMan->getName() << " and " << m_pWoman->getName() << " are bad." << endl;
        }  
    }

private:
    Person *m_pMan;
    Person *m_pWoman;
};

class Woman : public Person
{
public:
    Woman(string name, int sex, int condi, Mediator *mediator)
    : Person(name, sex, condi, mediator)
    {}

    virtual void getParter(Person *person) override
    {
        m_mediator->setWoman(this);
        m_mediator->setMan(person);
        m_mediator->getParter();
    }
};

class Man : public Person
{
public:
    Man(string name, int sex, int condi, Mediator *mediator)
    : Person(name, sex, condi, mediator)
    {}

    virtual void getParter(Person *person) override
    {
        m_mediator->setWoman(person);
        m_mediator->setMan(this);
        m_mediator->getParter();
    }
};

void test0(){
    Mediator *mediator = new Mediator();
    Person *xiaofang = new Woman("xiaofang", 2, 5, mediator);
    Person *zhangsan = new Woman("zhangsan", 1, 4, mediator);
    Person *lisi = new Woman("lisi", 1, 5, mediator);
    xiaofang->getParter(zhangsan);
    xiaofang->getParter(lisi);
}
~~~



#### 4.6 观察者模式

##### 3.2.1 基本概念

- 定义对象间一对多的关，一个对象改变通知其他所有对象

##### 3.2.2 类图及职责

![image-20220718232446163](assets/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/image-20220718232446163.png)

##### 3.3.3 代码实现

~~~C++
class Secretary;

class PlayserObserver
{
public:
    PlayserObserver(Secretary *secretary)
    : m_secretary(secretary)
    {

    }

    void update(string action)
    {
        cout << "action" << action << endl; 
    }

private:
    Secretary *m_secretary;
};

class Secretary
{
public:
    void notify(string action)
    {
        for(PlayserObserver* it: m_list){
            it->update(action);
        }  
    }

    void setPlayserObserver(PlayserObserver *o)
    {
        m_list.push_back(o);
    }

private:
    list<PlayserObserver*> m_list;
};

void test0(){
    Secretary *secretary = new Secretary();
    PlayserObserver *ob1 = new PlayserObserver(secretary);
    PlayserObserver *ob2 = new PlayserObserver(secretary);
    PlayserObserver *ob3 = new PlayserObserver(secretary);

    secretary->setPlayserObserver(ob1);
    secretary->setPlayserObserver(ob2);
    secretary->setPlayserObserver(ob3);

    secretary->notify("Boss Come in!!!");
    secretary->notify("Boss goes~");

    delete secretary;
    delete ob1;
    delete ob2;
    delete ob3;
}
~~~



#### 4.7 备忘录模式

##### 3.2.1 基本概念

- 保持对象的状态，在需要的时候恢复

##### 3.2.2 类图及职责

![image-20220718232617698](assets/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/image-20220718232617698.png)

- Originator
  - 保存状态，以便恢复的那个对象
- Memenot
  - 备忘录
  - 保存Originator
- Caretaker
  - 管理者
  - 负责保存状态和恢复状态

##### 3.3.3 代码实现

~~~C++
class MememTo
{
public:
    MememTo(string name, int age)
    : m_name(name)
    , m_age(age)
    {}

    string name() const
    {
        return m_name;
    }

    int age() const
    {
        return m_age;
    }

    void setName(string name)
    {
        m_name = name;
    }

    void setAge(int age)
    {
        m_age = age;
    }

private:
    string m_name;
    int m_age;
};

class Person
{
public:
    Person(string name, int age)
    : m_name(name)
    , m_age(age)
    {}

    string name() const
    {
        return m_name;
    }

    int age() const
    {
        return m_age;
    }

    void setName(string name)
    {
        m_name = name;
    }

    void setAge(int age)
    {
        m_age = age;
    }

    MememTo* createMemTo()
    {
        return new MememTo(m_name, m_age);
    }

    void setMememTo(MememTo *memto)
    {
        m_age = memto->age();
        m_name = memto->name();
    }
    
    void print() const
    {
        cout << m_name << " " << m_age << endl;
    }

private:
    string m_name;
    int m_age;
};

class Caretaker
{
public:
    Caretaker(MememTo *memto)
    : m_memto(memto)
    {}

    MememTo* memmTo()
    {
        return m_memto;
    }

    void setMememTo(MememTo *memto)
    {
        m_memto = memto;
    }

private:
    MememTo *m_memto;
};

void test0(){
    Person *p = new Person("zhangsan", 15);
    MememTo *m = p->createMemTo();
    p->print();
    p->setName("lisi");
    p->setAge(18);
    p->print();
    p->setMememTo(m);
    p->print();
}

void test1(){
    Person *p = new Person("zhangsan", 15);
    Caretaker *caretaker = new Caretaker(p->createMemTo());
    p->print();
    p->setName("lisi");
    p->setAge(18);
    p->print();
    p->setMememTo(caretaker->memmTo());
    p->print();
}
~~~



#### 4.8 访问者模式

##### 3.2.1 基本概念

- 将对象的数据和行为分离
- 适用于
  - 把数据结构和作用于数据结构上的操作解耦合
  - 适用于数据结构比较稳定的场合


##### 3.2.2 类图及职责

![image-20220719214427571](assets/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/image-20220719214427571.png)	

##### 3.3.3 代码实现

~~~C++
class ParkElement;

class Vistor
{
public:
    virtual void visit(ParkElement * parkElement) = 0; 
};

class ParkElement
{
public:
    virtual void accept(Vistor *vistor) = 0;
};

class ParkA : public ParkElement
{
    virtual void accept(Vistor *vistor) override
    {
        vistor->visit(this);
    }
};

class ParkB : public ParkElement
{
    virtual void accept(Vistor *vistor) override
    {
        vistor->visit(this);
    }
};

class Park : public ParkElement
{
public:
    Park()
    {
        m_list.clear();
    }

    void setParkElement(ParkElement *p)
    {
        m_list.push_back(p);
    }

    virtual void accept(Vistor *v) override
    {
        for(const auto &park: m_list){
            v->visit(park);
        }
    }

private:
    list<ParkElement*> m_list;    
};

class VistorA : public Vistor
{
public:
    virtual void visit(ParkElement * parkElement) override
    {
        cout << "vistor A done ParkA dasao" << endl;
    }
};

class VistorB : public Vistor
{
public:
    virtual void visit(ParkElement * parkElement) override
    {
        cout << "vistor B done ParkB dasao" << endl;
    }
};

class ManageVisitor : public Vistor
{
public:
    virtual void visit(ParkElement *istor) override
    {
        cout << "visit all" << endl;
    }

};

void test0(){
    Vistor *vA = new VistorA();
    ParkElement *pA = new ParkA();

    Vistor *vB = new VistorB();
    ParkElement *pB = new ParkB();

    pA->accept(vA);
    pB->accept(vB);

    delete vA;
    delete vB;
    delete pA;
    delete pA;
}

void test1()
{
    Vistor *manage = new ManageVisitor();
    Park *park = new Park();
    ParkElement *pA = new ParkA();
    ParkElement *pB = new ParkB();
    park->setParkElement(pA);
    park->setParkElement(pB);
    
    park->accept(manage);
}

~~~



#### 4.9 状态模式

##### 3.2.1 基本概念

- 通过用户的状态，改变对象的行为

##### 3.2.2 类图及职责

![image-20220719220602479](assets/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/image-20220719220602479.png)

- Context 用户对象
  - 拥有一个state类型成员，用来标识当前的状态
- state 接口或者基类
  - 封装和Context有关的行为
- ConcreteState
  - 实现了一个与Context某个状态相关的行为

##### 3.3.3 代码实现

~~~C++
class Worker;

class State
{
public:
    virtual void doSomeThing(Worker *w) = 0;
};

class Worker
{
public:
    Worker();

    void setHour(int hour)
    {
        m_hour = hour;
    }

    int getHour()
    {
        return m_hour;
    }

    State* getCurrentState()
    {
        return m_currState;
    }

    void setCurrentState(State *state)
    {
        m_currState = state;
    }

    void doSomeThing()
    {
        m_currState->doSomeThing(this);
    }

private:
    int m_hour;
    State *m_currState;
};

class State1 : public State
{
public:
    virtual void doSomeThing(Worker *w) override;
};

class State2 : public State
{
public:
    virtual void doSomeThing(Worker *w) override;
};

void State1::doSomeThing(Worker *w)
{
    if(w->getHour() == 7 || w->getHour() == 8){
        cout << "eat morning" << endl;
    }
    else{
        delete w->getCurrentState();
        w->setCurrentState(new State2());
        w->getCurrentState()->doSomeThing(w);
    }
}

void State2::doSomeThing(Worker *w)
{
    if(w->getHour() == 9 || w->getHour() == 10){
        cout << "working" << endl;
    }
    else{
        delete w->getCurrentState();
        w->setCurrentState(new State1());
        cout << "Current time is " << w->getHour() << " no state" << endl;
    }
}

Worker::Worker()
: m_hour(0)
, m_currState(new State1)
{}

void test0(){
    Worker *w1 = new Worker();
    w1->setHour(7);
    w1->doSomeThing();

    w1->setHour(9);
    w1->doSomeThing();

    delete w1;
}
~~~



#### 4.10 解释器模式

##### 3.2.1 基本概念

- 一些应用，定义一些脚本或者宏，将其的含义解释出来

##### 3.2.2 类图及职责

![image-20220719223149340](assets/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/image-20220719223149340.png)

- Context
  - 解释器上下文环境类
- AbstractExpresson
  - 解释器抽象类
- ConcreteExpress
  - 解释器具体类

##### 3.3.3 代码实现

~~~C++
class Context
{
public:
    Context(int num)
    : m_num(num)
    {}

    int getNum(){
        return m_num;
    }

    int getRes(){
        return m_res;
    }

    void setNum(int num){
        m_num = num;
    }

    void setRes(int res){
        m_res = res;
    }

private:
    int m_num;
    int m_res;
};

class Expression
{
public:
    virtual void interpreter(Context *context) = 0;
};

class PlusExpression : public Expression
{
public:
    PlusExpression(Context *context)
    : m_context(context)
    {}

    virtual void interpreter(Context *context) override
    {
        int num = context->getNum();
        ++num;
        context->setNum(num);
        context->setRes(num);
    }

private:
    Context *m_context;
};

class MinusExpression : public Expression
{
public:
    MinusExpression(Context *context)
    : m_context(context)
    {}

    virtual void interpreter(Context *context) override
    {
        int num = context->getNum();
        --num;
        context->setNum(num);
        context->setRes(num);
    }

private:
    Context *m_context;
};

void test0(){
    Context *context = new Context(15);
    Expression *expression = new PlusExpression(context);
    cout << context->getNum() << endl;
    expression->interpreter(context);
    cout << context->getNum() << endl;
    delete expression;
    expression = new MinusExpression(context);
    expression->interpreter(context);
    cout << context->getNum() << endl;
    delete expression;
}
~~~



#### 4.11 迭代器模式

##### 3.2.1 基本概念

- 

##### 3.2.2 类图及职责

![image-20220720001328106](assets/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/image-20220720001328106.png)

##### 3.3.3 代码实现

~~~C++
typedef int Object;
const int SIZE = 5;

class MyIterator
{
public:
    virtual void first() = 0;
    virtual void next() = 0;
    virtual bool isDone() = 0;
    virtual Object currentItem() = 0;
};

class Aggregate
{
public:
    virtual MyIterator* createIterator() = 0;
    virtual Object getItem(int index) = 0;
    virtual int size() = 0;
};

class ContreteIterator : public MyIterator
{
public:
    ContreteIterator(Aggregate *ag)
    : m_ag(ag)
    , m_currentIndex(0)
    {}

    virtual void first() override
    {
        m_currentIndex = 0;
    }

    virtual void next() override
    {
        if(m_currentIndex < m_ag->size()){
            ++m_currentIndex;
        }
    }
    
    virtual bool isDone() override
    {
        return m_currentIndex == m_ag->size();  
    }

    virtual Object currentItem() override
    {
        return m_ag->getItem(m_currentIndex);
    }

private:
    int m_currentIndex;
    Aggregate *m_ag;
};

class ConcreteAggregate : public Aggregate
{
public:
    ConcreteAggregate()
    {
        for(int i = 0; i < SIZE; ++i){
            m_objects[i] = 100 + i;
        }
    }

    virtual MyIterator* createIterator() override
    {
        return new ContreteIterator(this);
    }

    virtual Object getItem(int index) override
    {
        return m_objects[index];
    }

    virtual int size() override
    {
        return SIZE;
    }

private:
    Object m_objects[SIZE];
};

void test0(){
    Aggregate *agg = new ConcreteAggregate();
    MyIterator *iter = agg->createIterator();
    for(int i = 0; i < SIZE; ++i){
        cout << iter->currentItem() << " ";
        iter->next();
    }
    cout << endl;
}
~~~

